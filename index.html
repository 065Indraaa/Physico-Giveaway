<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<title>Detect & Derive (Tanpa Bruteforce) — Pubkey / Seed</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
body{font-family:ui-monospace,monospace;padding:18px;max-width:980px;margin:auto;background:#f7fafc;}
label{display:block;margin:10px 0 6px 0;font-weight:600;}
input,button,select,textarea{font-size:15px;padding:8px 10px;border-radius:6px;border:1px solid #ccc;width:100%;}
button{width:auto;cursor:pointer;margin-right:8px;}
#output{white-space:pre-wrap;background:#fff;border:1px solid #ddd;padding:12px;height:50vh;overflow:auto;font-size:13px;line-height:1.45;}
.hit{background:#e6ffed;padding:6px;border-radius:4px;}
.small{font-size:12px;color:#555;margin-top:6px;}
.row{display:flex;gap:8px;align-items:center;}
.row > *{flex:1;}
</style>
</head>
<body>
<h2>Detect & Derive (Tanpa Bruteforce)</h2>

<label>RPC endpoint:
  <input id="rpcUrl" value="https://api.mainnet-beta.solana.com">
</label>

<div class="row" style="margin:8px 0;">
  <div style="flex:1">
    <label>Target Base58 / Base64 / HEX / seed:
      <input id="targetInput" placeholder="tempel pubkey / seed / secretKey (base58/base64/hex)">
    </label>
  </div>
  <div style="width:140px">
    <label>&nbsp;
      <button id="checkBtn">Cek</button>
    </label>
  </div>
</div>

<div style="margin-bottom:8px;">
  <button id="clearBtn">Clear</button>
  <button id="helpBtn">Petunjuk singkat</button>
</div>

<div id="status" class="small">Ready — tempel pubkey atau seed lalu klik "Cek".</div>
<div id="output"></div>

<script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
<script>
/* ---------- util base58 (encode/decode) ---------- */
const ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function encodeBase58(buffer){
  let digits=[0];
  for(let i=0;i<buffer.length;i++){
    let carry = buffer[i];
    for(let j=0;j<digits.length;j++){ carry += digits[j]<<8; digits[j] = carry % 58; carry = (carry/58)|0; }
    while(carry>0){ digits.push(carry%58); carry=(carry/58)|0; }
  }
  for(let k=0;k<buffer.length && buffer[k]===0;k++) digits.push(0);
  return digits.reverse().map(d=>ALPHABET[d]).join('');
}
function decodeBase58(str){
  if(typeof str !== 'string') throw new Error('not string');
  const bytes=[0];
  for(let i=0;i<str.length;i++){
    const idx = ALPHABET.indexOf(str[i]);
    if(idx === -1) throw new Error('invalid base58 char');
    let carry = idx;
    for(let j=0;j<bytes.length;j++){ carry += bytes[j]*58; bytes[j] = carry & 0xff; carry = carry >> 8; }
    while(carry>0){ bytes.push(carry & 0xff); carry = carry >> 8; }
  }
  // convert little-endian bytes -> big-endian Uint8Array
  const out = new Uint8Array(bytes.length);
  for(let i=0;i<bytes.length;i++) out[i] = bytes[bytes.length-1-i];
  // leading zeros (base58 '1')
  let nPad = 0;
  for(let i=0;i<str.length && str[i] === ALPHABET[0]; i++) nPad++;
  if(nPad>0){
    const withPad = new Uint8Array(out.length + nPad);
    withPad.set(out, nPad);
    return withPad;
  }
  return out;
}

/* ---------- helpers hex/base64 ---------- */
function isHex(s){ return /^[0-9a-fA-F]+$/.test(s.replace(/^0x/,'')); }
function hexToBytes(hex){
  hex = hex.replace(/^0x/,'');
  if(hex.length%2) hex = '0'+hex;
  const u = new Uint8Array(hex.length/2);
  for(let i=0;i<u.length;i++) u[i] = parseInt(hex.slice(i*2,i*2+2),16);
  return u;
}
function uint8ToHex(u){ return Array.from(u).map(b=>b.toString(16).padStart(2,'0')).join(''); }
function base64ToBytes(s){
  try{
    const bin = atob(s);
    const u = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) u[i] = bin.charCodeAt(i);
    return u;
  }catch(e){ throw new Error('invalid base64');}
}

/* ---------- RPC ---------- */
async function rpcPost(url, body, timeoutMs=20000){
  const ctr = new AbortController();
  const id = setTimeout(()=>ctr.abort(), timeoutMs);
  try{
    const res = await fetch(url, { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(body), signal: ctr.signal });
    clearTimeout(id);
    return await res.json();
  }catch(e){ clearTimeout(id); throw e; }
}
async function getBalanceRpc(rpcUrl, pubkey){
  const body = { jsonrpc:"2.0", id:1, method:"getBalance", params:[pubkey] };
  const r = await rpcPost(rpcUrl, body);
  if(r && r.result && typeof r.result.value !== 'undefined') return r.result.value;
  return null;
}

/* ---------- UI utils ---------- */
const out = document.getElementById('output');
const status = document.getElementById('status');
function clearOut(){ out.textContent=''; }
function log(s){ const d=document.createElement('div'); d.textContent=s; out.appendChild(d); out.scrollTop = out.scrollHeight; }
function hit(s){ const d=document.createElement('div'); d.className='hit'; d.textContent=s; out.appendChild(d); out.scrollTop = out.scrollHeight; }
function warn(s){ const d=document.createElement('div'); d.style.color='crimson'; d.textContent=s; out.appendChild(d); out.scrollTop = out.scrollHeight; }

/* ---------- core check flow (NO BRUTEFORCE) ---------- */
async function analyzeInput(raw){
  clearOut();
  status.textContent = 'Mencoba mendeteksi format...';
  raw = String(raw).trim();
  if(!raw){ status.textContent='Input kosong.'; return; }

  const rpcUrl = document.getElementById('rpcUrl').value.trim();

  // 1) Try Base58 decode
  let triedSomething = false;
  try{
    const dec = decodeBase58(raw);
    triedSomething = true;
    log('Base58 decode: OK — byte length = ' + dec.length);
    // If 32 bytes: could be pubkey or seed. Show both interpretations.
    if(dec.length === 32){
      // interpret as pubkey raw bytes
      const asPub = encodeBase58(dec);
      log('Interpretasi A (sebagai pubkey bytes): ' + asPub);
      try{
        status.textContent = 'Fetching balance (interpretasi pubkey)...';
        const bal = await getBalanceRpc(rpcUrl, asPub);
        log(`Balance (as pubkey): ${bal}`);
      }catch(e){ log('Gagal fetch balance untuk interpretasi pubkey.'); }

      // interpret as seed -> derive pubkey
      try{
        const seed = dec;
        const kp = nacl.sign.keyPair.fromSeed(seed);
        const derivedPub = encodeBase58(kp.publicKey);
        log('Interpretasi B (sebagai seed 32 bytes) -> derived pubkey: ' + derivedPub);
        try{
          status.textContent = 'Fetching balance (interpretasi seed-derived)...';
          const bal2 = await getBalanceRpc(rpcUrl, derivedPub);
          log(`Balance (derived pubkey): ${bal2}`);
        }catch(e){ log('Gagal fetch balance untuk derived pubkey.'); }
      }catch(e){
        log('Tidak bisa derive from seed (tweetnacl error).');
      }

      status.textContent = 'Selesai (32-byte base58). Periksa hasil di bawah.';
      return;
    }

    // 64 bytes maybe secretKey (seed+pub)
    if(dec.length === 64){
      log('Interpretasi: Base58 64 bytes — mungkin secretKey (seed+pub).');
      const seed = dec.slice(0,32);
      const seedHex = uint8ToHex(seed);
      log('Seed (hex): ' + seedHex);
      try{
        const kp = nacl.sign.keyPair.fromSeed(seed);
        const derivedPub = encodeBase58(kp.publicKey);
        hit('Derived pubkey: ' + derivedPub);
        try{
          status.textContent = 'Fetching balance...';
          const bal = await getBalanceRpc(rpcUrl, derivedPub);
          log('Balance: ' + bal);
        }catch(e){ log('Gagal fetch balance.'); }
      }catch(e){ log('Gagal derive keypair.'); }
      status.textContent = 'Selesai (64-byte base58).';
      return;
    }

    // other lengths: still show encoded pubkey if length==32 etc, otherwise inform
    log('Decoded base58 length not 32/64 — tampilkan hex: ' + uint8ToHex(dec));
    status.textContent = 'Hasil decode base58 (panjang tidak biasa).';
    return;
  }catch(e){
    // not base58
  }

  // 2) Try Hex
  try{
    const s = raw.replace(/^0x/,'');
    if(s.length >= 2 && s.length%2===0 && isHex(s)){
      triedSomething = true;
      const bytes = hexToBytes(s);
      log('Hex decode OK — length bytes = ' + bytes.length);
      if(bytes.length === 32){
        // treat as seed and/or pubkey
        hit('Hex 32 bytes — interpretasi seed/pubkey:');
        // interpret as pubkey
        try{
          const asPub = encodeBase58(bytes);
          log('Interpretasi pubkey: ' + asPub);
          try{
            status.textContent = 'Fetching balance (hex->pubkey)...';
            const bal = await getBalanceRpc(rpcUrl, asPub);
            log('Balance: ' + bal);
          }catch(e){ log('Gagal fetch balance (hex->pubkey).'); }
        }catch(e){}

        // interpret as seed -> derive
        try{
          const kp = nacl.sign.keyPair.fromSeed(bytes);
          const derivedPub = encodeBase58(kp.publicKey);
          log('Interpretasi seed -> derived pubkey: ' + derivedPub);
          try{
            status.textContent = 'Fetching balance (derived)...';
            const bal2 = await getBalanceRpc(rpcUrl, derivedPub);
            log('Balance derived: ' + bal2);
          }catch(e){ log('Gagal fetch balance untuk derived.'); }
        }catch(e){}
        status.textContent = 'Selesai (hex 32 bytes).';
        return;
      } else if(bytes.length === 64){
        log('Hex 64 bytes — try seed+pub (take first 32 bytes as seed).');
        const seed = bytes.slice(0,32);
        const kp = nacl.sign.keyPair.fromSeed(seed);
        const derivedPub = encodeBase58(kp.publicKey);
        hit('Derived pubkey: ' + derivedPub);
        try{
          status.textContent = 'Fetching balance...';
          const bal = await getBalanceRpc(rpcUrl, derivedPub);
          log('Balance: ' + bal);
        }catch(e){ log('Gagal fetch balance.'); }
        status.textContent = 'Selesai (hex 64 bytes).';
        return;
      } else {
        log('Hex decode length bukan 32/64 — tidak dapat derive tanpa informasi tambahan.');
        status.textContent = 'Decode hex selesai (panjang tidak biasa).';
        return;
      }
    }
  }catch(e){
    // ignore
  }

  // 3) Try base64
  try{
    const bytes = base64ToBytes(raw);
    triedSomething = true;
    log('Base64 decode OK — length bytes = ' + bytes.length);
    if(bytes.length === 32){
      hit('Base64 32 bytes — interpretasi seed/pubkey:');
      // as pubkey
      const asPub = encodeBase58(bytes);
      log('Interpretasi pubkey: ' + asPub);
      try{
        status.textContent = 'Fetching balance (base64->pubkey)...';
        const bal = await getBalanceRpc(rpcUrl, asPub);
        log('Balance: ' + bal);
      }catch(e){ log('Gagal fetch balance.'); }
      // as seed
      try{
        const kp = nacl.sign.keyPair.fromSeed(bytes);
        const derivedPub = encodeBase58(kp.publicKey);
        log('Interpretasi seed -> derived pubkey: ' + derivedPub);
        try{
          status.textContent = 'Fetching balance (derived)...';
          const bal2 = await getBalanceRpc(rpcUrl, derivedPub);
          log('Balance derived: ' + bal2);
        }catch(e){ log('Gagal fetch balance derived.'); }
      }catch(e){}
      status.textContent = 'Selesai (base64 32 bytes).';
      return;
    } else if(bytes.length === 64){
      log('Base64 64 bytes — treated as secretKey maybe. Using first 32 bytes as seed.');
      const seed = bytes.slice(0,32);
      const kp = nacl.sign.keyPair.fromSeed(seed);
      const derivedPub = encodeBase58(kp.publicKey);
      hit('Derived pubkey: ' + derivedPub);
      try{
        status.textContent = 'Fetching balance...';
        const bal = await getBalanceRpc(rpcUrl, derivedPub);
        log('Balance: ' + bal);
      }catch(e){ log('Gagal fetch balance.'); }
      status.textContent = 'Selesai (base64 64 bytes).';
      return;
    } else {
      log('Base64 decoded length bukan 32/64.');
      status.textContent = 'Base64 decode selesai (panjang tidak biasa).';
      return;
    }
  }catch(e){
    // not base64
  }

  // 4) Fallback: treat input as pubkey string and try fetching balance directly
  if(!triedSomething){
    log('Tidak terdeteksi format seed/secret. Mencoba treat sebagai pubkey string dan fetch balance...');
  } else {
    log('Format terdeteksi tapi tidak cocok untuk derive. Mencoba treat sebagai pubkey string dan fetch balance...');
  }
  try{
    status.textContent = 'Fetching balance (treat as pubkey)...';
    const bal = await getBalanceRpc(rpcUrl, raw);
    hit(raw + ' | Balance: ' + bal);
    status.textContent = 'Selesai (treat-as-pubkey).';
    return;
  }catch(e){
    warn('Gagal fetch balance sebagai pubkey. Kemungkinan input bukan pubkey/seed/secret yang valid, atau RPC error.');
    status.textContent = 'Tidak bisa decode atau fetch — tanpa brute-force tidak mungkin menemukan seed dari pubkey.';
    log('Saran:');
    log('- Jika kamu memiliki seed (32 bytes) atau secretKey (64 bytes) dalam format lain, paste format itu (hex/base64/base58).');
    log('- Jika yang kamu punya hanyalah pubkey dan kamu ingin seed — satu-satunya cara adalah brute-force (sangat mahal/lama) atau menggunakan backup seed dari wallet asli.');
    log('- Jika ingin, saya bisa tambahkan opsi untuk memulai brute-force (tanggung jawab pengguna) — tapi sekarang skrip tidak melakukan brute-force.');
    return;
  }
}

/* ---------- hooks ---------- */
document.getElementById('checkBtn').addEventListener('click', async ()=>{
  const t = document.getElementById('targetInput').value;
  await analyzeInput(t);
});
document.getElementById('clearBtn').addEventListener('click', ()=>{ document.getElementById('targetInput').value=''; clearOut(); status.textContent='Ready'; });
document.getElementById('helpBtn').addEventListener('click', ()=>{
  clearOut();
  log('Petunjuk singkat:');
  log('- Tempel pubkey SOL (base58) → klik Cek → akan fetch balance.');
  log('- Tempel seed/secret (base58/base64/hex) 32/64 bytes → script akan decode dan derive pubkey + fetch balance.');
  log('- Jika input hanya pubkey dan kamu butuh seed: tidak mungkin tanpa brute-force. Skrip ini TIDAK melakukan brute-force.');
  status.textContent = 'Petunjuk ditampilkan.';
});
</script>
</body>
</html>
